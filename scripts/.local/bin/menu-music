#!/usr/bin/env bash

# An MPD music player menu and mpc wrapper.

usage() {
    cat << EOF
Usage: $(basename "$0") [operation]

An MPD music player menu with playback controls, playlist management, and lyrics support.
Can also be used as a direct wrapper for mpc operations.

Operations:
  play, pause, stop, previous, next, seek, replay
  select, current, add-folder, add-songs, playlist
  random, repeat, single, consume, lyrics, rescan

Examples:
  $(basename "$0")              # Show interactive menu
  $(basename "$0") play         # Play/pause music
  $(basename "$0") next         # Next track
  $(basename "$0") lyrics       # Show lyrics for current song
EOF
}

# Global configuration
DEPENDENCIES=(mpc menu notify-send)
COVER="/tmp/mpd_albumart.jpg"

# Check for required dependencies
check_dependencies() {
    for DEPENDENCY in "${DEPENDENCIES[@]}"; do
        type -p "$DEPENDENCY" &> /dev/null || {
            echo "error: Could not find '${DEPENDENCY}', is it installed?" >&2
            exit 1
        }
    done
}

# Build main menu options with current MPD states
#
# Outputs:
#   A list of options, one per line
build_main_menu() {
    STATES=$(mpc --format "" | sed -rn 's/.*repeat: (on|off)[ ]+random: (on|off)[ ]+single: (on|off)[ ]+consume: (on|off).*/\1 \2 \3 \4/p')
    REPEAT_STATE=$(echo "$STATES" | cut -f 1 -d ' ')
    RANDOM_STATE=$(echo "$STATES" | cut -f 2 -d ' ')
    SINGLE_STATE=$(echo "$STATES" | cut -f 3 -d ' ')
    CONSUME_STATE=$(echo "$STATES" | cut -f 4 -d ' ')

    echo -e "  󰐊 Play\n  󰏤 Pause\n  󰓛 Stop\n  󰒮 Previous\n  󰒭 Next\n   Seek\n  󰑙 Replay\n  󰆤 Select\n   Current\n  󰉗 Add folder\n  󰷞 Add songs\n  󰲸 Playlist\n   Random [$RANDOM_STATE]\n   Repeat [$REPEAT_STATE]\n  󰎦 Single [$SINGLE_STATE]\n  󰮯 Consume [$CONSUME_STATE]\n  󰍰 Lyrics\n  󰑓 Rescan"
}

# Toggle play/pause
play_pause() {
    mpc -q toggle
}

# Stop playback
stop() {
    mpc -q stop
}

# Play previous track
previous() {
    mpc -q prev
}

# Play next track
next() {
    mpc -q next
}

# Seek to position in current track
seek() {
    SEEK_OPTS=("0%" "10%" "20%" "30%" "40%" "50%" "60%" "70%" "80%" "90%")
    POSITION=$(printf "%s\n" "${SEEK_OPTS[@]}" | menu run -p "  󰎇 Seek: ")
    if [[ -n $POSITION ]]; then
        mpc -q seek "$POSITION"
    fi
}

# Replay current track
replay() {
    mpc -q stop
    mpc -q play
}

# Select song from playlist
select_song() {
    CANDIDATES=$(mpc playlist --format '%position%  [%title%|%file%]')
    SELECTION=$(menu run -p "  󰎇 Song:" <<< "$CANDIDATES")

    if [[ $(mpc --format "" | sed -rn 's/.*consume: (on|off).*/\1/p') != "on" ]] && [[ -n $SELECTION ]]; then
        NUM_SONG=$(awk '{print $1}' <<< "$SELECTION")
        mpc -q play "$NUM_SONG"
    fi
}

# Show current track information
show_current() {
    if [ "$(mpc status | wc -l)" != "1" ]; then
        TITLE=$(mpc current --format "[%title%]")
        if [ "$TITLE" != "" ]; then
            ALBUM=$(mpc current --format "[%album%]")
            ARTIST=$(mpc current --format "[%artist%]")
            if [ "$ALBUM" = "$TITLE" ]; then
                notify-send "Playing $TITLE" "by <b>$ARTIST</b>" -i "$COVER"
            else
                notify-send "Playing $TITLE" "from <i>$ALBUM</i> by <b>$ARTIST</b>" -i "$COVER"
            fi
        else
            notify-send "Playing $(mpc current --format '[%file%]')" -i "$COVER"
        fi
    else
        notify-send "Music: No playback"
    fi
}

# Recursive function to list all folders
#
# Arguments:
#   $1 - The base path
#   $2 - The current path
#
# Outputs:
#   A list of folders, one per line
list_folders_recursive() {
    local base_path="$1"
    local current_path="$2"

    if [[ -z $current_path ]]; then
        # Top level - list all artists/folders
        mpc ls | while read -r folder; do
            echo "$folder"
            list_folders_recursive "$folder" "$folder"
        done
    else
        # Check if current path has sub-folders
        mpc ls "$current_path" 2> /dev/null | while read -r item; do
            # Check if it's a folder (no file extension) and not empty
            if [[ $item != *"."* && -n $item ]]; then
                local full_path="$current_path/$item"
                echo "$full_path"
                # Recursively check this sub-folder
                list_folders_recursive "$base_path" "$full_path"
            fi
        done
    fi
}

# Add music folder to playlist
add_folder() {
    # Get all folders recursively from MPD database
    MUSIC_DIR_LIST=$(list_folders_recursive)

    QUERY=$(menu run -p "  󰎇 Folder:" <<< "$MUSIC_DIR_LIST")

    if [[ -n $QUERY ]]; then
        mpc ls "$QUERY" | mpc -q add
    fi
}

# Search and add songs to playlist
add_songs() {
    FLTR_OPTS=("any" "artist" "album" "title" "track" "name" "genre" "date" "composer" "performer" "comment" "disc" "filename")
    FLTR_TYPE="$(printf "%s\n" "${FLTR_OPTS[@]}" | menu run -p "  󰎇 Filter type:")"
    [[ -z $FLTR_TYPE ]] || ! printf "%s\n" "${FLTR_OPTS[@]}" | grep -Fxq "$FLTR_TYPE" && return

    QUERY="$(menu run -p "  󰎇 Query [$FLTR_TYPE]:" <<< "")"
    [[ -z $QUERY ]] && return

    if [[ $FLTR_TYPE == "any" ]]; then
        SEARCH_RESULTS=$(mpc search any "$QUERY" 2> /dev/null)
    else
        SEARCH_RESULTS=$(mpc search "$FLTR_TYPE" "$QUERY" 2> /dev/null)
    fi

    if [[ -z $SEARCH_RESULTS ]]; then
        notify-send "Music: No results found" "for '$QUERY' in $FLTR_TYPE"
        return
    fi

    declare -A RESULTS_ARR
    while IFS= read -r LINE; do
        [[ -z $LINE ]] && continue

        FILE_PATH=$(echo "$LINE" | sed 's/^file: //')

        ARTIST=$(mpc listall -f "%artist%" "$FILE_PATH" 2> /dev/null)
        ALBUM=$(mpc listall -f "%album%" "$FILE_PATH" 2> /dev/null)
        TITLE=$(mpc listall -f "%title%" "$FILE_PATH" 2> /dev/null)

        [[ -z $TITLE ]] && TITLE=$(basename "$FILE_PATH" | sed 's/\.[^.]*$//')

        if [[ -n $ARTIST && -n $ALBUM ]]; then
            PRESENT_LINE="$TITLE from $ALBUM by $ARTIST"
        elif [[ -n $ARTIST ]]; then
            PRESENT_LINE="$TITLE by $ARTIST"
        else
            PRESENT_LINE="$TITLE"
        fi

        RESULTS_ARR+=(["$FILE_PATH"]="$PRESENT_LINE")
    done < <(echo "$SEARCH_RESULTS")

    if [[ ${#RESULTS_ARR[@]} -eq 0 ]]; then
        notify-send "Music: No results found" "for '$QUERY' in $FLTR_TYPE"
        return
    fi

    COUNT=0
    SELECTION="a"
    while [[ -n $SELECTION ]] && [[ ${#RESULTS_ARR[@]} -gt 0 ]]; do
        SELECTION="$(menu run -p "  󰎇 Results [$COUNT]:" <<< "$(printf "%s\n" "${RESULTS_ARR[@]}")")"
        if [[ -n $SELECTION ]]; then
            SELECTION_KEY=""
            for URIKEY in "${!RESULTS_ARR[@]}"; do
                if [[ ${RESULTS_ARR["$URIKEY"]} == "$SELECTION" ]]; then
                    SELECTION_KEY="$URIKEY"
                    break
                fi
            done

            if [[ -n $SELECTION_KEY ]]; then
                unset RESULTS_ARR[$SELECTION_KEY]
                if [[ $COUNT -eq 0 ]]; then
                    CURR_LENGTH=$(mpc playlist | wc -l)
                    mpc -q add "$SELECTION_KEY"
                    PLAY_NOW=$(menu run -p "  󰎇 Start playing now?" <<< $'yes\nno')
                    if [[ $PLAY_NOW == "yes" ]]; then
                        mpc -q play $((CURR_LENGTH + 1))
                    fi
                else
                    mpc -q add "$SELECTION_KEY"
                fi
                ((COUNT++))
                notify-send "Music: Added song" "$(basename "$SELECTION_KEY")"
            fi
        fi
    done
}

# Add all available music to playlist
playlist_add_all() {
    if [[ $(menu run -p "  󰎇 Add all available music to playlist?" <<< $'yes\nno') == "yes" ]]; then
        mpc ls | mpc -q add
    fi
}

# Remove songs from playlist
playlist_remove_song() {
    SELECTION="a"
    while [[ -n $SELECTION ]]; do
        mapfile -t CANDIDATES_ARR < <(mpc playlist --format '%position%  [%title%|%file%]')
        if [[ ${#CANDIDATES_ARR[@]} -eq 0 ]]; then
            notify-send "Music: Playlist is empty"
            return
        fi

        SELECTION=$(printf "%s\n" "${CANDIDATES_ARR[@]}" | menu run -p "  󰎇 Song: ")
        if [[ -n $SELECTION ]]; then
            NUM_SONG=$(awk '{print $1}' <<< "$SELECTION")
            if [[ $(menu run -p "  󰎇 Remove this song?" <<< $'yes\nno') == "yes" ]]; then
                mpc -q del "$NUM_SONG"
                notify-send "Music: Removed song" "$(echo "$SELECTION" | sed 's/^[0-9]*  \[//; s/\]$//')"
            fi
        fi
    done
}

# Clear current playlist
playlist_clear() {
    if [[ $(menu run -p "  󰎇 Clear playlist?" <<< $'yes\nno') == "yes" ]]; then
        mpc -q clear
        notify-send "Music: Cleared playlist"
    fi
}

# Load saved playlist
playlist_load() {
    PLAYLIST=$(menu run -p "  󰎇 Load: " <<< "$(mpc lsplaylists)")
    if [[ -n $PLAYLIST ]]; then
        mpc -q stop
        mpc -q clear
        mpc -q load "$PLAYLIST"
        notify-send "Music: Playlist loaded" "$PLAYLIST"
    fi
}

# Save current playlist
playlist_save() {
    PLAYLIST=$(menu run -p "  󰎇 Save: " <<< "$(mpc lsplaylists)")
    if [[ -n $PLAYLIST ]]; then
        mpc save "$PLAYLIST"
        notify-send "Music: Playlist saved" "$PLAYLIST"
    fi
}

# Delete saved playlist
playlist_delete() {
    PLAYLIST=$(menu run -p "  󰎇 Delete: " <<< "$(mpc lsplaylists)")
    if [[ -n $PLAYLIST ]]; then
        mpc rm "$PLAYLIST"
        notify-send "Music: Playlist deleted" "$PLAYLIST"
    fi
}

# Show playlist management menu
playlist_menu() {
    PLIST_OPTS=("  󰐒 Add all available" "  󰐐 Remove a song" "  󰐐 Clear" "  󰗇 Load" "  󰷲 Save" "  󰐓 Delete")
    ACTION=$(printf "%s\n" "${PLIST_OPTS[@]}" | menu run -p "  󰎇 Option: " | tr '[:upper:]' '[:lower:]' | sed 's/^[^a-zA-Z]*//' | sed 's/[^a-zA-Z]*$//')

    case "$ACTION" in
        'add all available') playlist_add_all ;;
        'remove a song') playlist_remove_song ;;
        'clear') playlist_clear ;;
        'load') playlist_load ;;
        'save') playlist_save ;;
        'delete') playlist_delete ;;
    esac
}

# Toggle random mode
toggle_random() {
    mpc -q random
}

# Toggle repeat mode
toggle_repeat() {
    mpc -q repeat
}

# Toggle single mode
toggle_single() {
    mpc -q single
}

# Toggle consume mode
toggle_consume() {
    mpc -q consume
}

# Show or create lyrics for current song
show_lyrics() {
    SONG=$(mpc current)
    LYRICS_FILE="${XDG_DATA_HOME:-$HOME/.local/share}/music_library/lyrics/$SONG.txt"
    if [[ ! -d "$(dirname "$LYRICS_FILE")" ]]; then
        mkdir -p "$(dirname "$LYRICS_FILE")"
    fi

    if command -v open > /dev/null 2>&1; then
        OPEN_COMMAND="open"
    else
        OPEN_COMMAND="xdg-open"
    fi

    if [[ ! -f $LYRICS_FILE ]]; then
        HOW=$(menu run -p "  󰎇 Create lyrics? " <<< $'auto\nmanual')
        if [[ $HOW == "auto" ]]; then
            clyrics "$(mpc current --format "[%artist%]")" "$(mpc current --format "[%title%]")" >> "$LYRICS_FILE"
            if [[ $? -ne 0 ]]; then
                notify-send "Lyrics not found for the song:" "$SONG"
            else
                notify-send "Saved lyrics file for the song:" "$SONG at <u>$LYRICS_FILE</u>."
            fi
        else
            touch "$LYRICS_FILE"
            $OPEN_COMMAND "$LYRICS_FILE" &
            notify-send "Created lyrics file for the song:" "$SONG at <u>$LYRICS_FILE</u>."
        fi
    else
        $OPEN_COMMAND "$LYRICS_FILE" &
    fi
}

# Update music database
rescan() {
    notify-send "Music: Updating database"
    mpc -q update
    mopidy local scan > /dev/null 2>&1
}

# Main entry point
main() {
    check_dependencies

    if [[ $# -gt 0 ]]; then
        ACTION="$1"
    else
        ACTION=$(menu run -p "  󰎇  " <<< "$(build_main_menu)")
        ACTION=$(echo "$ACTION" | tr '[:upper:]' '[:lower:]' | sed 's/ \[.*\]//' | sed 's/^[^a-zA-Z]*//' | tr ' ' '-')
    fi

    if [[ -z $ACTION ]]; then
        exit 0
    fi

    case "$ACTION" in
        play | pause) play_pause ;;
        stop) stop ;;
        previous) previous ;;
        next) next ;;
        seek) seek ;;
        replay) replay ;;
        select) select_song ;;
        current) show_current ;;
        add-folder) add_folder ;;
        add-songs) add_songs ;;
        playlist) playlist_menu ;;
        random | shuffle) toggle_random ;;
        repeat) toggle_repeat ;;
        single) toggle_single ;;
        consume) toggle_consume ;;
        lyrics) show_lyrics ;;
        rescan) rescan ;;
        -h | --help | help)
            usage
            exit 0
            ;;
        *)
            echo "Unknown operation: $ACTION" >&2
            usage >&2
            exit 1
            ;;
    esac
}

main "$@"
