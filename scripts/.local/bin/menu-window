#!/usr/bin/env bash

# A menu for window selection and management.

# Global configuration
DEPENDENCIES=(wmctrl xprop xrandr display)

usage() {
    cat << EOF
Usage: $(basename "$0")

A menu for window selection and management.

This script displays a menu of available windows and allows you to focus on them.
EOF
}

# Check for required dependencies
check_dependencies() {
    for dependency in "${DEPENDENCIES[@]}"; do
        if ! command -v "$dependency" &> /dev/null; then
            echo "error: Could not find '${dependency}', is it installed?" >&2
            return 1
        fi
    done
}

# Get window name
#
# Arguments:
#   $1 - Window ID
#
# Outputs:
#   Writes window name to stdout
get_window_name() {
    local window_id="$1"
    local window_name

    window_name=$(xprop -id "$window_id" -notype -f _NET_WM_NAME 8u '=$0\n' _NET_WM_NAME | cut -f 2 -d =)
    if [[ $window_name == '_NET_WM_NAME=""' ]]; then
        window_name=$(xprop -id "$window_id" -notype -f WM_NAME 8u '=$0\n' WM_NAME | cut -f 2 -d =)
    fi
    echo "${window_name:1:-1}"
}

# Get window workspace
#
# Arguments:
#   $1 - Window ID
#   $2 - Array of workspace names
#
# Outputs:
#   Writes workspace name to stdout
get_window_workspace() {
    local window_id="$1"
    local -n names="$2"
    local workspace_index

    workspace_index=$(xprop -id "$window_id" -notype -f _NET_WM_DESKTOP 0c '=$0\n' _NET_WM_DESKTOP | cut -f 2 -d =)
    echo "${names[$workspace_index]:1:-1}"
}

# Build window entries for multi-display setup
#
# Arguments:
#   $1 - Array of window IDs
#   $2 - Array of workspace names
#
# Outputs:
#   Writes window entries to stdout
build_multi_display_entries() {
    local -n w_ids="$1"
    local -n ws_names="$2"

    for idx in "${!w_ids[@]}"; do
        local window_id="${w_ids[$idx]}"
        local window_name
        local window_workspace
        local window_display

        window_name=$(get_window_name "$window_id")
        window_workspace=$(get_window_workspace "$window_id" workspace_names)
        window_display=$(display window-display "$window_id")

        echo "$idx: [$window_display - $window_workspace] $window_name"
    done
}

# Build window entries for single display setup
#
# Arguments:
#   $1 - Array of window IDs
#   $2 - Array of workspace names
#
# Outputs:
#   Writes window entries to stdout
build_single_display_entries() {
    local -n w_ids="$1"
    local -n ws_names="$2"

    for idx in "${!w_ids[@]}"; do
        local window_id="${w_ids[$idx]}"
        local window_name
        local window_workspace

        window_name=$(get_window_name "$window_id")
        window_workspace=$(get_window_workspace "$window_id" workspace_names)

        echo "$idx: [$window_workspace] $window_name"
    done
}

# Main entry point
main() {
    check_dependencies || return 1

    local window_ids
    local workspace_names
    local num_monitors
    local window_entries=()
    local selected_window
    local window_id

    mapfile -t window_ids < <(xprop -root -notype -f _NET_CLIENT_LIST 0c '=$0+\n' _NET_CLIENT_LIST | tr -s "=, " "\n" | tail -n+2)
    mapfile -t workspace_names < <(xprop -root -notype -f _NET_DESKTOP_NAMES 8u '=$0+\n' _NET_DESKTOP_NAMES | tr -s "=, " "\n" | tail -n+2)
    num_monitors=$(xrandr --current | grep -c ' connected ')

    if [[ $num_monitors != "1" ]]; then
        # Multi-display setup
        mapfile -t window_entries < <(build_multi_display_entries window_ids workspace_names)
    else
        # Single display setup
        mapfile -t window_entries < <(build_single_display_entries window_ids workspace_names)
    fi

    # Create associative array for window selection
    declare -A window_map
    for entry in "${window_entries[@]}"; do
        local idx=$(echo "$entry" | cut -d: -f1)
        window_map["$entry"]="${window_ids[$idx]}"
    done

    selected_window=$(printf '%s\n' "${!window_map[@]}" | sort -n | menu run -p "  ")
    [ -n "$selected_window" ] && wmctrl -ia "${window_map["$selected_window"]}"
}

main "$@"
